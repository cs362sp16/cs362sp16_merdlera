        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:/******************************************************************************
        -:    9: * CARD EFFECTS
        -:   10: ******************************************************************************/
        -:   11:
    #####:   12:void card_adventurer(struct gameState *state, int currentPlayer){
    #####:   13:    int cardDrawn = 0;
    #####:   14:    int drawnTreasure = 0;
        -:   15:    int tempHand[MAX_HAND];
    #####:   16:    int z = 0; // for temp hand...
        -:   17:
    #####:   18:    while(drawnTreasure < 2){
        -:   19:        // If the deck is empty we need to shuffle discard & add to deck
    #####:   20:        if(state->deckCount[currentPlayer] < 1){
        -:   21:            //printf("Shuffle deck\n");
    #####:   22:            shuffle(currentPlayer, state);
        -:   23:        }
        -:   24:
        -:   25:        //printf("Draw card\n");
    #####:   26:        drawCard(currentPlayer, state);
        -:   27:
        -:   28:        //printf("Set card drawn\n");
        -:   29:        // Top card of hand is most recently drawn card
    #####:   30:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];
        -:   31:
    #####:   32:        if(cardDrawn == copper || cardDrawn == silver || cardDrawn == gold){
    #####:   33:            drawnTreasure++;
        -:   34:        }else{
        -:   35:            //printf("else\n");
    #####:   36:            tempHand[z] = cardDrawn;
    #####:   37:            state->handCount[currentPlayer]--; // rm most recent (top) card
    #####:   38:            z++;
        -:   39:        }
        -:   40:    }
        -:   41:
        -:   42:    //printf("discard cards in play\n");
    #####:   43:    while(z - 1 >= 0){
        -:   44:        // Discard all cards in play that have been drawn
    #####:   45:        state->discard[currentPlayer][state->discardCount[currentPlayer]++] = tempHand[z - 1];
    #####:   46:        z--;
        -:   47:    }
    #####:   48:}
        -:   49:
        6:   50:void card_councilRoom(struct gameState *state, int currentPlayer, int handPos){
        -:   51:    // Add four cards
       30:   52:    for(int i = 0; i < 4; i++){
       24:   53:        drawCard(currentPlayer, state);
        -:   54:    }
        -:   55:
        -:   56:    // Add buy
        6:   57:    state->numBuys++;
        -:   58:
        -:   59:    // Every other player draws a card
       26:   60:    for(int i = 0; i < state->numPlayers; i++){
       20:   61:        if(i != currentPlayer){
       14:   62:            drawCard(i, state);
        -:   63:        }
        -:   64:    }
        -:   65:
        6:   66:    discardCard(handPos, currentPlayer, state, 0);
        6:   67:}
        -:   68:
    #####:   69:void card_feast(struct gameState *state, int currentPlayer, int choice1){
        -:   70:    int tempHand[MAX_HAND];
        -:   71:
        -:   72:    // Gain a card with a cost of up to 5
        -:   73:    // Backup hand?
    #####:   74:    for(int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:   75:        tempHand[i] = state->hand[currentPlayer][i]; // Backup card
    #####:   76:        state->hand[currentPlayer][i] = -1; // Set to nothing
        -:   77:    }
        -:   78:
        -:   79:    // Update coins for buy phase
    #####:   80:    updateCoins(currentPlayer, state, 5);
        -:   81:
    #####:   82:    int x = 1;
    #####:   83:    while(x == 1){ // Buy one card
    #####:   84:        if(supplyCount(choice1, state) <= 0){
        -:   85:            if(DEBUG){
        -:   86:                printf("None of that card left, sorry!\n");
        -:   87:                printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:   88:            }
    #####:   89:        }else if(state->coins < getCost(choice1)){
    #####:   90:            printf("That card is too expensive!\n");
        -:   91:
        -:   92:            if(DEBUG){
        -:   93:                printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:   94:            }
        -:   95:        }else{
        -:   96:            if(DEBUG){
        -:   97:                printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:   98:            }
        -:   99:
    #####:  100:            gainCard(choice1, state, 0, currentPlayer); //Gain the card
    #####:  101:            x = 0; //No more buying cards
        -:  102:
        -:  103:            if(DEBUG){
        -:  104:                printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  105:            }
        -:  106:        }
        -:  107:    }
        -:  108:
        -:  109:    // Reset hand
    #####:  110:    for(int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  111:        state->hand[currentPlayer][i] = tempHand[i];
    #####:  112:        tempHand[i] = -1;
        -:  113:    }
    #####:  114:}
        -:  115:
        4:  116:int card_mine(struct gameState *state, int currentPlayer, int handPos, int choice1, int choice2){
        -:  117:    int j;
        -:  118:
        -:  119:    // Store card we will trash
        4:  120:    j = state->hand[currentPlayer][choice1];
        -:  121:
        4:  122:    if(state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold){
    #####:  123:        return 0;
        -:  124:    }
        -:  125:
        4:  126:    if (choice2 > treasure_map || choice2 < curse){
    #####:  127:        return 0;
        -:  128:    }
        -:  129:
        4:  130:    if((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2)){
        4:  131:        return 0;
        -:  132:    }
        -:  133:
    #####:  134:    gainCard(choice2, state, 2, currentPlayer);
        -:  135:
        -:  136:    //discard card from hand
    #####:  137:    discardCard(handPos, currentPlayer, state, 0);
        -:  138:
        -:  139:    //discard trashed card
    #####:  140:    for(int i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  141:        if(state->hand[currentPlayer][i] == j){
    #####:  142:            discardCard(i, currentPlayer, state, 0);
    #####:  143:            break;
        -:  144:        }
        -:  145:    }
        -:  146:
    #####:  147:    return -1;
        -:  148:}
        -:  149:
       60:  150:int card_remodel(struct gameState *state, int currentPlayer, int handPos, int choice1, int choice2){
        -:  151:    int j;
        -:  152:
        -:  153:    // Store card we will trash
       60:  154:    j = state->hand[currentPlayer][choice1];
        -:  155:
       60:  156:    if((getCost(state->hand[currentPlayer][choice1]) + 1) > getCost(choice2)){
       60:  157:        return -1;
        -:  158:    }
        -:  159:
    #####:  160:    gainCard(choice2, state, 0, currentPlayer);
        -:  161:
        -:  162:    //discard card from hand
    #####:  163:    discardCard(handPos, currentPlayer, state, 0);
        -:  164:
        -:  165:    //discard trashed card
    #####:  166:    for (int i = 0; i < state->handCount[currentPlayer] - 1; i++){
    #####:  167:        if (state->hand[currentPlayer][i] == j){
    #####:  168:            discardCard(i, currentPlayer, state, 0);
    #####:  169:            break;
        -:  170:        }
        -:  171:    }
        -:  172:
    #####:  173:    return 0;
        -:  174:}
        -:  175:
        -:  176:/******************************************************************************
        -:  177: * EVERYTHING ELSE
        -:  178: ******************************************************************************/
        -:  179:
   101068:  180:int compare(const void* a, const void* b) {
   101068:  181:    if (*(int*)a > *(int*)b)
    44786:  182:        return 1;
    56282:  183:    if (*(int*)a < *(int*)b)
    15522:  184:        return -1;
    40760:  185:    return 0;
        -:  186:}
        -:  187:
    #####:  188:struct gameState* newGame() {
    #####:  189:    struct gameState* g = malloc(sizeof(struct gameState));
    #####:  190:    return g;
        -:  191:}
        -:  192:
    #####:  193:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  194:                  int k8, int k9, int k10) {
    #####:  195:    int* k = malloc(10 * sizeof(int));
    #####:  196:    k[0] = k1;
    #####:  197:    k[1] = k2;
    #####:  198:    k[2] = k3;
    #####:  199:    k[3] = k4;
    #####:  200:    k[4] = k5;
    #####:  201:    k[5] = k6;
    #####:  202:    k[6] = k7;
    #####:  203:    k[7] = k8;
    #####:  204:    k[8] = k9;
    #####:  205:    k[9] = k10;
    #####:  206:    return k;
        -:  207:}
        -:  208:
       40:  209:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  210:                   struct gameState *state) {
        -:  211:
        -:  212:    int i;
        -:  213:    int j;
        -:  214:    int it;
        -:  215:    //set up random number generator
       40:  216:    SelectStream(1);
       40:  217:    PutSeed((long)randomSeed);
        -:  218:
        -:  219:    //check number of players
       40:  220:    if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:  221:    {
    #####:  222:        return -1;
        -:  223:    }
        -:  224:
        -:  225:    //set number of players
       40:  226:    state->numPlayers = numPlayers;
        -:  227:
        -:  228:    //check selected kingdom cards are different
      440:  229:    for (i = 0; i < 10; i++)
        -:  230:    {
     4400:  231:        for (j = 0; j < 10; j++)
        -:  232:        {
     4000:  233:            if (j != i && kingdomCards[j] == kingdomCards[i])
        -:  234:            {
    #####:  235:                return -1;
        -:  236:            }
        -:  237:        }
        -:  238:    }
        -:  239:
        -:  240:
        -:  241:    //initialize supply
        -:  242:    ///////////////////////////////
        -:  243:
        -:  244:    //set number of Curse cards
       40:  245:    if (numPlayers == 2)
        -:  246:    {
       20:  247:        state->supplyCount[curse] = 10;
        -:  248:    }
       20:  249:    else if (numPlayers == 3)
        -:  250:    {
        2:  251:        state->supplyCount[curse] = 20;
        -:  252:    }
        -:  253:    else
        -:  254:    {
       18:  255:        state->supplyCount[curse] = 30;
        -:  256:    }
        -:  257:
        -:  258:    //set number of Victory cards
       40:  259:    if (numPlayers == 2)
        -:  260:    {
       20:  261:        state->supplyCount[estate] = 8;
       20:  262:        state->supplyCount[duchy] = 8;
       20:  263:        state->supplyCount[province] = 8;
        -:  264:    }
        -:  265:    else
        -:  266:    {
       20:  267:        state->supplyCount[estate] = 12;
       20:  268:        state->supplyCount[duchy] = 12;
       20:  269:        state->supplyCount[province] = 12;
        -:  270:    }
        -:  271:
        -:  272:    //set number of Treasure cards
       40:  273:    state->supplyCount[copper] = 60 - (7 * numPlayers);
       40:  274:    state->supplyCount[silver] = 40;
       40:  275:    state->supplyCount[gold] = 30;
        -:  276:
        -:  277:    //set number of Kingdom cards
      840:  278:    for (i = adventurer; i <= treasure_map; i++)        //loop all cards
        -:  279:    {
     7272:  280:        for (j = 0; j < 10; j++)                        //loop chosen cards
        -:  281:        {
     6752:  282:            if (kingdomCards[j] == i)
        -:  283:            {
        -:  284:                //check if card is a 'Victory' Kingdom card
      280:  285:                if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  286:                {
       52:  287:                    if (numPlayers == 2) {
       16:  288:                        state->supplyCount[i] = 8;
        -:  289:                    }
       10:  290:                    else{ state->supplyCount[i] = 12; }
        -:  291:                }
        -:  292:                else
        -:  293:                {
      254:  294:                    state->supplyCount[i] = 10;
        -:  295:                }
      280:  296:                break;
        -:  297:            }
        -:  298:            else  //card is not in the set choosen for the game
        -:  299:            {
     6472:  300:                state->supplyCount[i] = -1;
        -:  301:            }
        -:  302:        }
        -:  303:
        -:  304:    }
        -:  305:
        -:  306:    ////////////////////////
        -:  307:    //supply intilization complete
        -:  308:
        -:  309:    //set player decks
      158:  310:    for (i = 0; i < numPlayers; i++)
        -:  311:    {
      118:  312:        state->deckCount[i] = 0;
      472:  313:        for (j = 0; j < 3; j++)
        -:  314:        {
      354:  315:            state->deck[i][j] = estate;
      354:  316:            state->deckCount[i]++;
        -:  317:        }
      944:  318:        for (j = 3; j < 10; j++)
        -:  319:        {
      826:  320:            state->deck[i][j] = copper;
      826:  321:            state->deckCount[i]++;
        -:  322:        }
        -:  323:    }
        -:  324:
        -:  325:    //shuffle player decks
      158:  326:    for (i = 0; i < numPlayers; i++)
        -:  327:    {
      118:  328:        if ( shuffle(i, state) < 0 )
        -:  329:        {
    #####:  330:            return -1;
        -:  331:        }
        -:  332:    }
        -:  333:
        -:  334:    //draw player hands
      158:  335:    for (i = 0; i < numPlayers; i++)
        -:  336:    {
        -:  337:        //initialize hand size to zero
      118:  338:        state->handCount[i] = 0;
      118:  339:        state->discardCount[i] = 0;
        -:  340:        //draw 5 cards
        -:  341:        // for (j = 0; j < 5; j++)
        -:  342:        //	{
        -:  343:        //	  drawCard(i, state);
        -:  344:        //	}
        -:  345:    }
        -:  346:
        -:  347:    //set embargo tokens to 0 for all supply piles
     1120:  348:    for (i = 0; i <= treasure_map; i++)
        -:  349:    {
     1080:  350:        state->embargoTokens[i] = 0;
        -:  351:    }
        -:  352:
        -:  353:    //initialize first player's turn
       40:  354:    state->outpostPlayed = 0;
       40:  355:    state->phase = 0;
       40:  356:    state->numActions = 1;
       40:  357:    state->numBuys = 1;
       40:  358:    state->playedCardCount = 0;
       40:  359:    state->whoseTurn = 0;
       40:  360:    state->handCount[state->whoseTurn] = 0;
        -:  361:    //int it; move to top
        -:  362:
        -:  363:    //Moved draw cards to here, only drawing at the start of a turn
      240:  364:    for (it = 0; it < 5; it++) {
      200:  365:        drawCard(state->whoseTurn, state);
        -:  366:    }
        -:  367:
       40:  368:    updateCoins(state->whoseTurn, state, 0);
        -:  369:
       40:  370:    return 0;
        -:  371:}
        -:  372:
     1748:  373:int shuffle(int player, struct gameState *state){
        -:  374:    int newDeck[MAX_DECK];
     1748:  375:    int newDeckPos = 0;
        -:  376:    int card;
        -:  377:    int i;
        -:  378:
     1748:  379:    if (state->deckCount[player] < 1)
    #####:  380:        return -1;
     1748:  381:    qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  382:    /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  383:
    36364:  384:    while (state->deckCount[player] > 0) {
    32868:  385:        card = floor(Random() * state->deckCount[player]);
    32868:  386:        newDeck[newDeckPos] = state->deck[player][card];
    32868:  387:        newDeckPos++;
   210950:  388:        for (i = card; i < state->deckCount[player]-1; i++) {
   178082:  389:            state->deck[player][i] = state->deck[player][i+1];
        -:  390:        }
    32868:  391:        state->deckCount[player]--;
        -:  392:    }
    34616:  393:    for (i = 0; i < newDeckPos; i++) {
    32868:  394:        state->deck[player][i] = newDeck[i];
    32868:  395:        state->deckCount[player]++;
        -:  396:    }
        -:  397:
     1748:  398:    return 0;
        -:  399:}
        -:  400:
      586:  401:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  402:{
        -:  403:    int card;
      586:  404:    int coin_bonus = 0;         //tracks coins gain from actions
        -:  405:
        -:  406:    //check if it is the right phase
      586:  407:    if (state->phase != 0)
        -:  408:    {
    #####:  409:        return -1;
        -:  410:    }
        -:  411:
        -:  412:    //check if player has enough actions
      586:  413:    if ( state->numActions < 1 )
        -:  414:    {
    #####:  415:        return -1;
        -:  416:    }
        -:  417:
        -:  418:    //get card played
      586:  419:    card = handCard(handPos, state);
        -:  420:
        -:  421:    //check if selected card is an action
      586:  422:    if ( card < adventurer || card > treasure_map )
        -:  423:    {
    #####:  424:        return -1;
        -:  425:    }
        -:  426:
        -:  427:    //play card
      586:  428:    if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  429:    {
      184:  430:        return -1;
        -:  431:    }
        -:  432:
        -:  433:    //reduce number of actions
      402:  434:    state->numActions--;
        -:  435:
        -:  436:    //update coins (Treasure cards may be added with card draws)
      402:  437:    updateCoins(state->whoseTurn, state, coin_bonus);
        -:  438:
      402:  439:    return 0;
        -:  440:}
        -:  441:
     5950:  442:int buyCard(int supplyPos, struct gameState *state) {
        -:  443:    int who;
        -:  444:    if (DEBUG) {
        -:  445:        printf("Entering buyCard...\n");
        -:  446:    }
        -:  447:
        -:  448:    // I don't know what to do about the phase thing.
        -:  449:
     5950:  450:    who = state->whoseTurn;
        -:  451:
     5950:  452:    if (state->numBuys < 1) {
        -:  453:        if (DEBUG)
        -:  454:            printf("You do not have any buys left\n");
    #####:  455:        return -1;
     5950:  456:    } else if (supplyCount(supplyPos, state) <1) {
        -:  457:        if (DEBUG)
        -:  458:            printf("There are not any of that type of card left\n");
     2630:  459:        return -1;
     3320:  460:    } else if (state->coins < getCost(supplyPos)) {
        -:  461:        if (DEBUG)
        -:  462:            printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  463:        return -1;
        -:  464:    } else {
     3320:  465:        state->phase=1;
        -:  466:        //state->supplyCount[supplyPos]--;
     3320:  467:        gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  468:
     3320:  469:        state->coins = (state->coins) - (getCost(supplyPos));
     3320:  470:        state->numBuys--;
        -:  471:        if (DEBUG)
        -:  472:            printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  473:    }
        -:  474:
        -:  475:    //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  476:    //state->discardCount[who]++;
        -:  477:
     3320:  478:    return 0;
        -:  479:}
        -:  480:
    36644:  481:int numHandCards(struct gameState *state) {
    36644:  482:    return state->handCount[ whoseTurn(state) ];
        -:  483:}
        -:  484:
      586:  485:int handCard(int handPos, struct gameState *state) {
      586:  486:    int currentPlayer = whoseTurn(state);
      586:  487:    return state->hand[currentPlayer][handPos];
        -:  488:}
        -:  489:
     9466:  490:int supplyCount(int card, struct gameState *state) {
     9466:  491:    return state->supplyCount[card];
        -:  492:}
        -:  493:
    #####:  494:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  495:    int i;
    #####:  496:    int count = 0;
        -:  497:
    #####:  498:    for (i = 0; i < state->deckCount[player]; i++)
        -:  499:    {
    #####:  500:        if (state->deck[player][i] == card) count++;
        -:  501:    }
        -:  502:
    #####:  503:    for (i = 0; i < state->handCount[player]; i++)
        -:  504:    {
    #####:  505:        if (state->hand[player][i] == card) count++;
        -:  506:    }
        -:  507:
    #####:  508:    for (i = 0; i < state->discardCount[player]; i++)
        -:  509:    {
    #####:  510:        if (state->discard[player][i] == card) count++;
        -:  511:    }
        -:  512:
    #####:  513:    return count;
        -:  514:}
        -:  515:
    49964:  516:int whoseTurn(struct gameState *state) {
    49964:  517:    return state->whoseTurn;
        -:  518:}
        -:  519:
     6074:  520:int endTurn(struct gameState *state) {
        -:  521:    int k;
        -:  522:    int i;
     6074:  523:    int currentPlayer = whoseTurn(state);
        -:  524:
        -:  525:    //Discard hand
    36252:  526:    for (i = 0; i < state->handCount[currentPlayer]; i++) {
    30178:  527:        state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i]; //Discard
    30178:  528:        state->hand[currentPlayer][i] = -1; //Set card to -1
        -:  529:    }
     6074:  530:    state->handCount[currentPlayer] = 0; //Reset hand count
        -:  531:
        -:  532:    //Code for determining the player
     6074:  533:    if (currentPlayer < (state->numPlayers - 1)) {
     3836:  534:        state->whoseTurn = currentPlayer + 1; //Still safe to increment
        -:  535:    }
        -:  536:    else{
     2238:  537:        state->whoseTurn = 0; //Max player has been reached, loop back around to player 1
        -:  538:    }
        -:  539:
     6074:  540:    state->outpostPlayed = 0;
     6074:  541:    state->phase = 0;
     6074:  542:    state->numActions = 1;
     6074:  543:    state->coins = 0;
     6074:  544:    state->numBuys = 1;
     6074:  545:    state->playedCardCount = 0;
     6074:  546:    state->handCount[state->whoseTurn] = 0;
        -:  547:
        -:  548:    //int k; move to top
        -:  549:    //Next player draws hand
    36444:  550:    for (k = 0; k < 5; k++) {
    30370:  551:        drawCard(state->whoseTurn, state); //Draw a card
        -:  552:    }
        -:  553:
        -:  554:    //Update money
     6074:  555:    updateCoins(state->whoseTurn, state, 0);
        -:  556:
     6074:  557:    return 0;
        -:  558:}
        -:  559:
     6116:  560:int isGameOver(struct gameState *state) {
        -:  561:    int i;
        -:  562:    int j;
        -:  563:
        -:  564:    //if stack of Province cards is empty, the game ends
     6116:  565:    if (state->supplyCount[province] == 0)
        -:  566:    {
    #####:  567:        return 1;
        -:  568:    }
        -:  569:
        -:  570:    //if three supply pile are at 0, the game ends
     6116:  571:    j = 0;
   159016:  572:    for (i = 0; i < 25; i++)
        -:  573:    {
   152900:  574:        if (state->supplyCount[i] == 0)
        -:  575:        {
     5440:  576:            j++;
        -:  577:        }
        -:  578:    }
     6116:  579:    if ( j >= 3)
        -:  580:    {
       40:  581:        return 1;
        -:  582:    }
        -:  583:
     6076:  584:    return 0;
        -:  585:}
        -:  586:
    #####:  587:int scoreFor (int player, struct gameState *state) {
        -:  588:
        -:  589:    int i;
    #####:  590:    int score = 0;
        -:  591:    //score from hand
    #####:  592:    for (i = 0; i < state->handCount[player]; i++)
        -:  593:    {
    #####:  594:        if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  595:        if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  596:        if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  597:        if (state->hand[player][i] == province) { score = score + 6; };
    #####:  598:        if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  599:        if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  600:    }
        -:  601:
        -:  602:    //score from discard
    #####:  603:    for (i = 0; i < state->discardCount[player]; i++)
        -:  604:    {
    #####:  605:        if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  606:        if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  607:        if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  608:        if (state->discard[player][i] == province) { score = score + 6; };
    #####:  609:        if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  610:        if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  611:    }
        -:  612:
        -:  613:    //score from deck
    #####:  614:    for (i = 0; i < state->discardCount[player]; i++)
        -:  615:    {
    #####:  616:        if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  617:        if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  618:        if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  619:        if (state->deck[player][i] == province) { score = score + 6; };
    #####:  620:        if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  621:        if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  622:    }
        -:  623:
    #####:  624:    return score;
        -:  625:}
        -:  626:
    #####:  627:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  628:    int i;
        -:  629:    int j;
        -:  630:    int highScore;
        -:  631:    int currentPlayer;
        -:  632:
        -:  633:    //get score for each player
    #####:  634:    for (i = 0; i < MAX_PLAYERS; i++)
        -:  635:    {
        -:  636:        //set unused player scores to -9999
    #####:  637:        if (i >= state->numPlayers)
        -:  638:        {
    #####:  639:            players[i] = -9999;
        -:  640:        }
        -:  641:        else
        -:  642:        {
    #####:  643:            players[i] = scoreFor (i, state);
        -:  644:        }
        -:  645:    }
        -:  646:
        -:  647:    //find highest score
    #####:  648:    j = 0;
    #####:  649:    for (i = 0; i < MAX_PLAYERS; i++)
        -:  650:    {
    #####:  651:        if (players[i] > players[j])
        -:  652:        {
    #####:  653:            j = i;
        -:  654:        }
        -:  655:    }
    #####:  656:    highScore = players[j];
        -:  657:
        -:  658:    //add 1 to players who had less turns
    #####:  659:    currentPlayer = whoseTurn(state);
    #####:  660:    for (i = 0; i < MAX_PLAYERS; i++)
        -:  661:    {
    #####:  662:        if ( players[i] == highScore && i > currentPlayer )
        -:  663:        {
    #####:  664:            players[i]++;
        -:  665:        }
        -:  666:    }
        -:  667:
        -:  668:    //find new highest score
    #####:  669:    j = 0;
    #####:  670:    for (i = 0; i < MAX_PLAYERS; i++)
        -:  671:    {
    #####:  672:        if ( players[i] > players[j] )
        -:  673:        {
    #####:  674:            j = i;
        -:  675:        }
        -:  676:    }
    #####:  677:    highScore = players[j];
        -:  678:
        -:  679:    //set winners in array to 1 and rest to 0
    #####:  680:    for (i = 0; i < MAX_PLAYERS; i++)
        -:  681:    {
    #####:  682:        if ( players[i] == highScore )
        -:  683:        {
    #####:  684:            players[i] = 1;
        -:  685:        }
        -:  686:        else
        -:  687:        {
    #####:  688:            players[i] = 0;
        -:  689:        }
        -:  690:    }
        -:  691:
    #####:  692:    return 0;
        -:  693:}
        -:  694:
    30800:  695:int drawCard(int player, struct gameState *state)
        -:  696:{
        -:  697:    int count;
        -:  698:    int deckCounter;
    30800:  699:    if (state->deckCount[player] <= 0) { //Deck is empty
        -:  700:
        -:  701:        //Step 1 Shuffle the discard pile back into a deck
        -:  702:        int i;
        -:  703:        //Move discard to deck
    33318:  704:        for (i = 0; i < state->discardCount[player]; i++) {
    31688:  705:            state->deck[player][i] = state->discard[player][i];
    31688:  706:            state->discard[player][i] = -1;
        -:  707:        }
        -:  708:
     1630:  709:        state->deckCount[player] = state->discardCount[player];
     1630:  710:        state->discardCount[player] = 0; //Reset discard
        -:  711:
        -:  712:        //Shufffle the deck
     1630:  713:        shuffle(player, state); //Shuffle the deck up and make it so that we can draw
        -:  714:
        -:  715:        if (DEBUG) { //Debug statements
        -:  716:            printf("Deck count now: %d\n", state->deckCount[player]);
        -:  717:        }
        -:  718:
     1630:  719:        state->discardCount[player] = 0;
        -:  720:
        -:  721:        //Step 2 Draw Card
     1630:  722:        count = state->handCount[player]; //Get current player's hand count
        -:  723:
        -:  724:        if (DEBUG) { //Debug statements
        -:  725:            printf("Current hand count: %d\n", count);
        -:  726:        }
        -:  727:
     1630:  728:        deckCounter = state->deckCount[player]; //Create a holder for the deck count
        -:  729:
     1630:  730:        if (deckCounter == 0)
    #####:  731:            return -1;
        -:  732:
     1630:  733:        state->hand[player][count] = state->deck[player][deckCounter - 1]; //Add card to hand
     1630:  734:        state->deckCount[player]--;
     1630:  735:        state->handCount[player]++; //Increment hand count
        -:  736:    }
        -:  737:
        -:  738:    else{
    29170:  739:        int count = state->handCount[player]; //Get current hand count for player
        -:  740:        int deckCounter;
        -:  741:        if (DEBUG) { //Debug statements
        -:  742:            printf("Current hand count: %d\n", count);
        -:  743:        }
        -:  744:
    29170:  745:        deckCounter = state->deckCount[player]; //Create holder for the deck count
    29170:  746:        state->hand[player][count] = state->deck[player][deckCounter - 1]; //Add card to the hand
    29170:  747:        state->deckCount[player]--;
    29170:  748:        state->handCount[player]++; //Increment hand count
        -:  749:    }
        -:  750:
    30800:  751:    return 0;
        -:  752:}
        -:  753:
    34892:  754:int getCost(int cardNumber)
        -:  755:{
    34892:  756:    switch( cardNumber )
        -:  757:    {
        -:  758:    case curse:
     2406:  759:        return 0;
        -:  760:    case estate:
     1778:  761:        return 2;
        -:  762:    case duchy:
     1140:  763:        return 5;
        -:  764:    case province:
     1132:  765:        return 8;
        -:  766:    case copper:
     2924:  767:        return 0;
        -:  768:    case silver:
     1600:  769:        return 3;
        -:  770:    case gold:
     1076:  771:        return 6;
        -:  772:    case adventurer:
      998:  773:        return 6;
        -:  774:    case council_room:
     1066:  775:        return 5;
        -:  776:    case feast:
     1140:  777:        return 4;
        -:  778:    case gardens:
     1134:  779:        return 4;
        -:  780:    case mine:
     1088:  781:        return 5;
        -:  782:    case remodel:
     1126:  783:        return 4;
        -:  784:    case smithy:
     1138:  785:        return 4;
        -:  786:    case village:
     1188:  787:        return 3;
        -:  788:    case baron:
     1112:  789:        return 4;
        -:  790:    case great_hall:
     1288:  791:        return 3;
        -:  792:    case minion:
     1050:  793:        return 5;
        -:  794:    case steward:
     1108:  795:        return 3;
        -:  796:    case tribute:
     1108:  797:        return 5;
        -:  798:    case ambassador:
     1428:  799:        return 3;
        -:  800:    case cutpurse:
     1100:  801:        return 4;
        -:  802:    case embargo:
     1278:  803:        return 2;
        -:  804:    case outpost:
     1060:  805:        return 5;
        -:  806:    case salvager:
     1122:  807:        return 4;
        -:  808:    case sea_hag:
     1084:  809:        return 4;
        -:  810:    case treasure_map:
     1160:  811:        return 4;
        -:  812:    }
        -:  813:
       60:  814:    return -1;
        -:  815:}
        -:  816:
      586:  817:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus){
        -:  818:    int i;
        -:  819:    int j;
        -:  820:    int k;
        -:  821:    int index;
      586:  822:    int currentPlayer = whoseTurn(state);
      586:  823:    int nextPlayer = currentPlayer + 1;
        -:  824:
      586:  825:    int tributeRevealedCards[2] = {-1, -1};
      586:  826:    if (nextPlayer > (state->numPlayers - 1)) {
      214:  827:        nextPlayer = 0;
        -:  828:    }
        -:  829:
        -:  830:    //uses switch to select card and perform actions
      586:  831:    switch(card){
        -:  832:        case adventurer:
    #####:  833:            card_adventurer(state, currentPlayer);
    #####:  834:            return 0;
        -:  835:
        -:  836:        case council_room:
        6:  837:            card_councilRoom(state, currentPlayer, handPos);
        6:  838:            return 0;
        -:  839:
        -:  840:        case feast:
    #####:  841:            card_feast(state, currentPlayer, choice1);
    #####:  842:            return 0;
        -:  843:
        -:  844:        case gardens:
       38:  845:            return -1;
        -:  846:
        -:  847:        case mine:
        4:  848:            return card_mine(state, currentPlayer, handPos, choice1, choice2);
        -:  849:
        -:  850:        case remodel:
       60:  851:            return card_remodel(state, currentPlayer, handPos, choice1, choice2);
        -:  852:
        -:  853:        case smithy:
        -:  854:            //+3 Cards
       80:  855:            for (i = 0; i < 3; i++)
        -:  856:            {
       60:  857:                drawCard(currentPlayer, state);
        -:  858:            }
        -:  859:
        -:  860:            //discard card from hand
       20:  861:            discardCard(handPos, currentPlayer, state, 0);
       20:  862:            return 0;
        -:  863:
        -:  864:        case village:
        -:  865:            //+1 Card
       36:  866:            drawCard(currentPlayer, state);
        -:  867:
        -:  868:            //+2 Actions
       36:  869:            state->numActions = state->numActions + 2;
        -:  870:
        -:  871:            //discard played card from hand
       36:  872:            discardCard(handPos, currentPlayer, state, 0);
       36:  873:            return 0;
        -:  874:
        -:  875:        case baron:
       40:  876:            state->numBuys++; //Increase buys by 1!
       40:  877:            if (choice1 > 0) { //Boolean true or going to discard an estate
    #####:  878:                int p = 0; //Iterator for hand!
    #####:  879:                int card_not_discarded = 1; //Flag for discard set!
    #####:  880:                while(card_not_discarded) {
    #####:  881:                    if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
    #####:  882:                        state->coins += 4; //Add 4 coins to the amount of coins
    #####:  883:                        state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  884:                        state->discardCount[currentPlayer]++;
    #####:  885:                        for (; p < state->handCount[currentPlayer]; p++) {
    #####:  886:                            state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  887:                        }
    #####:  888:                        state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  889:                        state->handCount[currentPlayer]--;
    #####:  890:                        card_not_discarded = 0; //Exit the loop
        -:  891:                    }
    #####:  892:                    else if (p > state->handCount[currentPlayer]) {
        -:  893:                        if(DEBUG) {
        -:  894:                            printf("No estate cards in your hand, invalid choice\n");
        -:  895:                            printf("Must gain an estate if there are any\n");
        -:  896:                        }
    #####:  897:                        if (supplyCount(estate, state) > 0) {
    #####:  898:                            gainCard(estate, state, 0, currentPlayer);
    #####:  899:                            state->supplyCount[estate]--; //Decrement estates
    #####:  900:                            if (supplyCount(estate, state) == 0) {
    #####:  901:                                isGameOver(state);
        -:  902:                            }
        -:  903:                        }
    #####:  904:                        card_not_discarded = 0; //Exit the loop
        -:  905:                    }
        -:  906:
        -:  907:                    else{
    #####:  908:                        p++; //Next card
        -:  909:                    }
        -:  910:                }
        -:  911:            }
        -:  912:
        -:  913:            else{
       40:  914:                if (supplyCount(estate, state) > 0) {
        8:  915:                    gainCard(estate, state, 0, currentPlayer); //Gain an estate
        8:  916:                    state->supplyCount[estate]--; //Decrement Estates
        8:  917:                    if (supplyCount(estate, state) == 0) {
        2:  918:                        isGameOver(state);
        -:  919:                    }
        -:  920:                }
        -:  921:            }
        -:  922:
        -:  923:
       40:  924:            return 0;
        -:  925:
        -:  926:        case great_hall:
        -:  927:            //+1 Card
       48:  928:            drawCard(currentPlayer, state);
        -:  929:
        -:  930:            //+1 Actions
       48:  931:            state->numActions++;
        -:  932:
        -:  933:            //discard card from hand
       48:  934:            discardCard(handPos, currentPlayer, state, 0);
       48:  935:            return 0;
        -:  936:
        -:  937:        case minion:
        -:  938:            //+1 action
        6:  939:            state->numActions++;
        -:  940:
        -:  941:            //discard card from hand
        6:  942:            discardCard(handPos, currentPlayer, state, 0);
        -:  943:
        6:  944:            if (choice1)            //+2 coins
        -:  945:            {
        6:  946:                state->coins = state->coins + 2;
        -:  947:            }
        -:  948:
    #####:  949:            else if (choice2)       //discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  950:            {
        -:  951:                //discard hand
    #####:  952:                while(numHandCards(state) > 0)
        -:  953:                {
    #####:  954:                    discardCard(handPos, currentPlayer, state, 0);
        -:  955:                }
        -:  956:
        -:  957:                //draw 4
    #####:  958:                for (i = 0; i < 4; i++)
        -:  959:                {
    #####:  960:                    drawCard(currentPlayer, state);
        -:  961:                }
        -:  962:
        -:  963:                //other players discard hand and redraw if hand size > 4
    #####:  964:                for (i = 0; i < state->numPlayers; i++)
        -:  965:                {
    #####:  966:                    if (i != currentPlayer)
        -:  967:                    {
    #####:  968:                        if ( state->handCount[i] > 4 )
        -:  969:                        {
        -:  970:                            //discard hand
    #####:  971:                            while( state->handCount[i] > 0 )
        -:  972:                            {
    #####:  973:                                discardCard(handPos, i, state, 0);
        -:  974:                            }
        -:  975:
        -:  976:                            //draw 4
    #####:  977:                            for (j = 0; j < 4; j++)
        -:  978:                            {
    #####:  979:                                drawCard(i, state);
        -:  980:                            }
        -:  981:                        }
        -:  982:                    }
        -:  983:                }
        -:  984:
        -:  985:            }
        6:  986:            return 0;
        -:  987:
        -:  988:        case steward:
       44:  989:            if (choice1 == 1)
        -:  990:            {
        -:  991:                //+2 cards
       20:  992:                drawCard(currentPlayer, state);
       20:  993:                drawCard(currentPlayer, state);
        -:  994:            }
       24:  995:            else if (choice1 == 2)
        -:  996:            {
        -:  997:                //+2 coins
       14:  998:                state->coins = state->coins + 2;
        -:  999:            }
        -: 1000:            else
        -: 1001:            {
        -: 1002:                //trash 2 cards in hand
       10: 1003:                discardCard(choice2, currentPlayer, state, 1);
       10: 1004:                discardCard(choice3, currentPlayer, state, 1);
        -: 1005:            }
        -: 1006:
        -: 1007:            //discard card from hand
       44: 1008:            discardCard(handPos, currentPlayer, state, 0);
       44: 1009:            return 0;
        -: 1010:
        -: 1011:        case tribute:
        6: 1012:            if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####: 1013:                if (state->deckCount[nextPlayer] > 0) {
    #####: 1014:                    tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1015:                    state->deckCount[nextPlayer]--;
        -: 1016:                }
    #####: 1017:                else if (state->discardCount[nextPlayer] > 0) {
    #####: 1018:                    tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1019:                    state->discardCount[nextPlayer]--;
        -: 1020:                }
        -: 1021:                else{
        -: 1022:                    //No Card to Reveal
        -: 1023:                    if (DEBUG) {
        -: 1024:                        printf("No cards to reveal\n");
        -: 1025:                    }
        -: 1026:                }
        -: 1027:            }
        -: 1028:
        -: 1029:            else{
        6: 1030:                if (state->deckCount[nextPlayer] == 0) {
    #####: 1031:                    for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####: 1032:                        state->deck[nextPlayer][i] = state->discard[nextPlayer][i]; //Move to deck
    #####: 1033:                        state->deckCount[nextPlayer]++;
    #####: 1034:                        state->discard[nextPlayer][i] = -1;
    #####: 1035:                        state->discardCount[nextPlayer]--;
        -: 1036:                    }
        -: 1037:
    #####: 1038:                    shuffle(nextPlayer,state); //Shuffle the deck
        -: 1039:                }
        6: 1040:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        6: 1041:                state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1042:                state->deckCount[nextPlayer]--;
        6: 1043:                tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        6: 1044:                state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1045:                state->deckCount[nextPlayer]--;
        -: 1046:            }
        -: 1047:
        6: 1048:            if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
    #####: 1049:                state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1050:                state->playedCardCount++;
    #####: 1051:                tributeRevealedCards[1] = -1;
        -: 1052:            }
        -: 1053:
       24: 1054:            for (i = 0; i <= 2; i++) {
       18: 1055:                if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
        6: 1056:                    state->coins += 2;
        -: 1057:                }
        -: 1058:
       12: 1059:                else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
        4: 1060:                    drawCard(currentPlayer, state);
        4: 1061:                    drawCard(currentPlayer, state);
        -: 1062:                }
        -: 1063:                else{ //Action Card
        8: 1064:                    state->numActions = state->numActions + 2;
        -: 1065:                }
        -: 1066:            }
        -: 1067:
        6: 1068:            return 0;
        -: 1069:
        -: 1070:        case ambassador:
      140: 1071:            j = 0;          //used to check if player has enough cards to discard
        -: 1072:
      140: 1073:            if (choice2 > 2 || choice2 < 0)
        -: 1074:            {
    #####: 1075:                return -1;
        -: 1076:            }
        -: 1077:
      140: 1078:            if (choice1 == handPos)
        -: 1079:            {
       36: 1080:                return -1;
        -: 1081:            }
        -: 1082:
      624: 1083:            for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1084:            {
      520: 1085:                if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1086:                {
       60: 1087:                    j++;
        -: 1088:                }
        -: 1089:            }
      104: 1090:            if (j < choice2)
        -: 1091:            {
       44: 1092:                return -1;
        -: 1093:            }
        -: 1094:
        -: 1095:            if (DEBUG)
        -: 1096:                printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1097:
        -: 1098:            //increase supply count for choosen card by amount being discarded
       60: 1099:            state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1100:
        -: 1101:            //each other player gains a copy of revealed card
      252: 1102:            for (i = 0; i < state->numPlayers; i++)
        -: 1103:            {
      192: 1104:                if (i != currentPlayer)
        -: 1105:                {
      132: 1106:                    gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1107:                }
        -: 1108:            }
        -: 1109:
        -: 1110:            //discard played card from hand
       60: 1111:            discardCard(handPos, currentPlayer, state, 0);
        -: 1112:
        -: 1113:            //trash copies of cards returned to supply
      120: 1114:            for (j = 0; j < choice2; j++)
        -: 1115:            {
      130: 1116:                for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:                {
      124: 1118:                    if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1119:                    {
       54: 1120:                        discardCard(i, currentPlayer, state, 1);
       54: 1121:                        break;
        -: 1122:                    }
        -: 1123:                }
        -: 1124:            }
        -: 1125:
       60: 1126:            return 0;
        -: 1127:
        -: 1128:        case cutpurse:
        -: 1129:
       26: 1130:            updateCoins(currentPlayer, state, 2);
       86: 1131:            for (i = 0; i < state->numPlayers; i++)
        -: 1132:            {
       60: 1133:                if (i != currentPlayer)
        -: 1134:                {
       34: 1135:                    for (j = 0; j < state->handCount[i]; j++)
        -: 1136:                    {
    #####: 1137:                        if (state->hand[i][j] == copper)
        -: 1138:                        {
    #####: 1139:                            discardCard(j, i, state, 0);
    #####: 1140:                            break;
        -: 1141:                        }
    #####: 1142:                        if (j == state->handCount[i])
        -: 1143:                        {
    #####: 1144:                            for (k = 0; k < state->handCount[i]; k++)
        -: 1145:                            {
        -: 1146:                                if (DEBUG)
        -: 1147:                                    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1148:                            }
    #####: 1149:                            break;
        -: 1150:                        }
        -: 1151:                    }
        -: 1152:
        -: 1153:                }
        -: 1154:
        -: 1155:            }
        -: 1156:
        -: 1157:            //discard played card from hand
       26: 1158:            discardCard(handPos, currentPlayer, state, 0);
        -: 1159:
       26: 1160:            return 0;
        -: 1161:
        -: 1162:
        -: 1163:        case embargo:
        -: 1164:            //+2 Coins
       66: 1165:            state->coins = state->coins + 2;
        -: 1166:
        -: 1167:            //see if selected pile is in play
       66: 1168:            if ( state->supplyCount[choice1] == -1 )
        -: 1169:            {
    #####: 1170:                return -1;
        -: 1171:            }
        -: 1172:
        -: 1173:            //add embargo token to selected supply pile
       66: 1174:            state->embargoTokens[choice1]++;
        -: 1175:
        -: 1176:            //trash card
       66: 1177:            discardCard(handPos, currentPlayer, state, 1);
       66: 1178:            return 0;
        -: 1179:
        -: 1180:        case outpost:
        -: 1181:            //set outpost flag
        4: 1182:            state->outpostPlayed++;
        -: 1183:
        -: 1184:            //discard card
        4: 1185:            discardCard(handPos, currentPlayer, state, 0);
        4: 1186:            return 0;
        -: 1187:
        -: 1188:        case salvager:
        -: 1189:            //+1 buy
        6: 1190:            state->numBuys++;
        -: 1191:
        6: 1192:            if (choice1)
        -: 1193:            {
        -: 1194:                //gain coins equal to trashed card
    #####: 1195:                state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1196:                //trash card
    #####: 1197:                discardCard(choice1, currentPlayer, state, 1);
        -: 1198:            }
        -: 1199:
        -: 1200:            //discard card
        6: 1201:            discardCard(handPos, currentPlayer, state, 0);
        6: 1202:            return 0;
        -: 1203:
        -: 1204:        case sea_hag:
      100: 1205:            for (i = 0; i < state->numPlayers; i++) {
       72: 1206:                if (i != currentPlayer) {
       44: 1207:                    state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];                        state->deckCount[i]--;
       44: 1208:                    state->discardCount[i]++;
       44: 1209:                    state->deck[i][state->deckCount[i]--] = curse; //Top card now a curse
        -: 1210:                }
        -: 1211:            }
       28: 1212:            return 0;
        -: 1213:
        -: 1214:        case treasure_map:
        -: 1215:            //search hand for another treasure_map
        8: 1216:            index = -1;
       40: 1217:            for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1218:            {
       34: 1219:                if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1220:                {
        2: 1221:                    index = i;
        2: 1222:                    break;
        -: 1223:                }
        -: 1224:            }
        8: 1225:            if (index > -1)
        -: 1226:            {
        -: 1227:                //trash both treasure cards
        2: 1228:                discardCard(handPos, currentPlayer, state, 1);
        2: 1229:                discardCard(index, currentPlayer, state, 1);
        -: 1230:
        -: 1231:                //gain 4 Gold cards
       10: 1232:                for (i = 0; i < 4; i++)
        -: 1233:                {
        8: 1234:                    gainCard(gold, state, 1, currentPlayer);
        -: 1235:                }
        -: 1236:
        -: 1237:                //return success
        2: 1238:                return 1;
        -: 1239:            }
        -: 1240:
        -: 1241:            //no second treasure_map found in hand
        6: 1242:            return -1;
        -: 1243:    }
        -: 1244:
    #####: 1245:    return -1;
        -: 1246:}
        -: 1247:
      400: 1248:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1249:{
        -: 1250:
        -: 1251:    //if card is not trashed, added to Played pile
      400: 1252:    if (trashFlag < 1)
        -: 1253:    {
        -: 1254:        //add card to played pile
      256: 1255:        state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      256: 1256:        state->playedCardCount++;
        -: 1257:    }
        -: 1258:
        -: 1259:    //set played card to -1
      400: 1260:    state->hand[currentPlayer][handPos] = -1;
        -: 1261:
        -: 1262:    //remove card from player's hand
      400: 1263:    if ( handPos == (state->handCount[currentPlayer] - 1) )     //last card in hand array is played
        -: 1264:    {
        -: 1265:        //reduce number of cards in hand
       34: 1266:        state->handCount[currentPlayer]--;
        -: 1267:    }
      366: 1268:    else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1269:    {
        -: 1270:        //reduce number of cards in hand
    #####: 1271:        state->handCount[currentPlayer]--;
        -: 1272:    }
        -: 1273:    else
        -: 1274:    {
        -: 1275:        //replace discarded card with last card in hand
      366: 1276:        state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1277:        //set last card to -1
      366: 1278:        state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1279:        //reduce number of cards in hand
      366: 1280:        state->handCount[currentPlayer]--;
        -: 1281:    }
        -: 1282:
      400: 1283:    return 0;
        -: 1284:}
        -: 1285:
     3468: 1286:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1287:{
        -: 1288:    //Note: supplyPos is enum of choosen card
        -: 1289:
        -: 1290:    //check if supply pile is empty (0) or card is not used in game (-1)
     3468: 1291:    if ( supplyCount(supplyPos, state) < 1 )
        -: 1292:    {
       12: 1293:        return -1;
        -: 1294:    }
        -: 1295:
        -: 1296:    //added card for [whoseTurn] current player:
        -: 1297:    // toFlag = 0 : add to discard
        -: 1298:    // toFlag = 1 : add to deck
        -: 1299:    // toFlag = 2 : add to hand
        -: 1300:
     3456: 1301:    if (toFlag == 1)
        -: 1302:    {
        8: 1303:        state->deck[ player ][ state->deckCount[player] ] = supplyPos;
        8: 1304:        state->deckCount[player]++;
        -: 1305:    }
     3448: 1306:    else if (toFlag == 2)
        -: 1307:    {
    #####: 1308:        state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1309:        state->handCount[player]++;
        -: 1310:    }
        -: 1311:    else
        -: 1312:    {
     3448: 1313:        state->discard[player][ state->discardCount[player] ] = supplyPos;
     3448: 1314:        state->discardCount[player]++;
        -: 1315:    }
        -: 1316:
        -: 1317:    //decrease number in supply pile
     3456: 1318:    state->supplyCount[supplyPos]--;
        -: 1319:
     3456: 1320:    return 0;
        -: 1321:}
        -: 1322:
    12616: 1323:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1324:{
        -: 1325:    int i;
        -: 1326:
        -: 1327:    //reset coin count
    12616: 1328:    state->coins = 0;
        -: 1329:
        -: 1330:    //add coins for each Treasure card in player's hand
    75320: 1331:    for (i = 0; i < state->handCount[player]; i++)
        -: 1332:    {
    62704: 1333:        if (state->hand[player][i] == copper)
        -: 1334:        {
    30384: 1335:            state->coins += 1;
        -: 1336:        }
    32320: 1337:        else if (state->hand[player][i] == silver)
        -: 1338:        {
     3270: 1339:            state->coins += 2;
        -: 1340:        }
    29050: 1341:        else if (state->hand[player][i] == gold)
        -: 1342:        {
       48: 1343:            state->coins += 3;
        -: 1344:        }
        -: 1345:    }
        -: 1346:
        -: 1347:    //add bonus
    12616: 1348:    state->coins += bonus;
        -: 1349:
    12616: 1350:    return 0;
        -: 1351:}
        -: 1352:
        -: 1353:
        -: 1354://end of dominion.c
